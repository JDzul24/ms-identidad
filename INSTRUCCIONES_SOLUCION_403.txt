ğŸ”§ SOLUCIÃ“N ERROR 403 - INSTRUCCIONES FRONTEND

ğŸ“‹ PROBLEMA IDENTIFICADO:
El error 403 ocurre porque la solicitud del atleta pertenece a un coach diferente.
En los logs se ve:
- Coach actual: 451da93f-927d-433e-b770-dcf59d7fbc3f
- Solicitud coachId: 819e60bf-0b19-426a-9d59-a467d5b327ae
- ValidaciÃ³n: coachEsDueÃ±o: false

âœ… SOLUCIÃ“N IMPLEMENTADA:
He creado un endpoint para limpiar solicitudes conflictivas y crear una nueva para el coach actual.

ğŸ“¡ NUEVO ENDPOINT:
POST https://api.capbox.site/identity/v1/atletas/{atletaId}/limpiar-solicitud

ğŸ”‘ HEADERS:
Authorization: Bearer <token-del-coach>

ğŸ“ EJEMPLO DE USO:
URL: POST https://api.capbox.site/identity/v1/atletas/dc7d78a2-aa06-48ef-a9d2-7d761322a71b/limpiar-solicitud
Headers: Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

ğŸ“Š RESPUESTA ESPERADA:
{
  "message": "Solicitud conflictiva eliminada y nueva solicitud creada",
  "solicitudAnterior": {
    "id": "e346f9fc-8c14-450e-8126-72ce901e217d",
    "coachId": "819e60bf-0b19-426a-9d59-a467d5b327ae",
    "status": "PENDIENTE"
  },
  "nuevaSolicitud": {
    "id": "nuevo-uuid-generado",
    "coachId": "451da93f-927d-433e-b770-dcf59d7fbc3f",
    "status": "PENDIENTE"
  }
}

ğŸš€ IMPLEMENTACIÃ“N EN FLUTTER:
```dart
Future<Map<String, dynamic>> limpiarSolicitudConflictiva(String atletaId) async {
  try {
    final response = await dio.post(
      '/identity/v1/atletas/$atletaId/limpiar-solicitud',
      options: Options(
        headers: {
          'Authorization': 'Bearer $token',
        },
      ),
    );
    
    print('ğŸ”§ LIMPIEZA: ${response.data}');
    return response.data;
  } catch (e) {
    print('âŒ LIMPIEZA ERROR: $e');
    rethrow;
  }
}
```

ğŸ“± FLUJO DE USO EN LA APP:
1. Cuando ocurra error 403, primero llamar al endpoint de debug
2. Si coachEsDueÃ±o = false, llamar al endpoint de limpieza
3. DespuÃ©s de la limpieza, intentar aprobar el atleta nuevamente

ğŸ”§ CÃ“DIGO COMPLETO PARA FLUTTER:
```dart
Future<void> aprobarAtletaConLimpieza(String atletaId, Map<String, dynamic> datos) async {
  try {
    // 1. Intentar aprobar directamente
    await aprobarAtleta(atletaId, datos);
  } catch (e) {
    if (e.toString().contains('403')) {
      print('ğŸ”§ Error 403 detectado, ejecutando limpieza...');
      
      // 2. Ejecutar debug para confirmar el problema
      final debugInfo = await debugSolicitud(atletaId);
      print('ğŸ” DEBUG: $debugInfo');
      
      // 3. Si coachEsDueÃ±o = false, limpiar solicitud
      if (debugInfo['validaciones']['coachEsDueÃ±o'] == false) {
        print('ğŸ”§ Ejecutando limpieza de solicitud conflictiva...');
        await limpiarSolicitudConflictiva(atletaId);
        
        // 4. Reintentar aprobaciÃ³n
        print('ğŸ”„ Reintentando aprobaciÃ³n despuÃ©s de limpieza...');
        await aprobarAtleta(atletaId, datos);
      } else {
        rethrow; // Otro tipo de error 403
      }
    } else {
      rethrow; // Otro tipo de error
    }
  }
}
```

ğŸ¯ OBJETIVO:
Eliminar la solicitud conflictiva y crear una nueva para el coach actual, permitiendo que pueda aprobar al atleta.

âš ï¸ IMPORTANTE:
- Este endpoint es seguro y solo elimina solicitudes pendientes
- Crea automÃ¡ticamente una nueva solicitud para el coach actual
- No afecta datos del atleta, solo las solicitudes de aprobaciÃ³n 